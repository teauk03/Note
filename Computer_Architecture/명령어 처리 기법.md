# 명령어 처리 기법

<br></br>
<br></br>

## 명령어 처리 과정 
![alt text](<설명사진/명령어 처리 과정.png>)
1. **명령어 인출(Instruction Fetch):** 다음에 실행할 명령어를 명령어 레지스터에 저장
2. **명령어 해석(Instruction Decode):** 명령어를 해석
3. **명령어 실행: (Execute Instruction):** 해석된 명령어를 바탕으로 명령어를 실행
4. **결과 저장(Write Back):** 실행된 결과를 메모리에 저장

<br></br>
<br></br>

## 명령어 파이프라인
**[순차적으로 명령어를 처리했을 경우]**
![alt text](<설명사진/순차적으로 명령어를 처리.png>)
* 하나의 명령어의 처리 까지 기달려야 함
* 비효율적임

**[파이프 라인을 사용했을 경우]**
![alt text](<설명사진/파이프 라인을 사용했을 경우.png>)
* CPU의 사용을 효율적으로 하기 위해 명령을 겹쳐서 실행하는 방법
* 하나의 코어에 여러개의 스레드를 사용하는 것
    * 하나의 명령어가 실행되는 동안, 다른 명령어를 실행을 시작하여 여러개의 명령어를 동시에 처리함
    * 명령어를 여러 단계로 나누어지고, 각 단계는 독립적으로 작동함
    * 인출, 해석, 실행, 저장의 단계를 병렬로 처리함 

<br></br>
<br></br>

## 파이프 라인 위험
![alt text](<설명사진/파이프라인 위험 종류.png>)

* 이렇게 효율적인 방법을 제공하는 파이프 라인에도 특정 상황에서 바보가 되는데, 그 바보가 되는 상황을 파이프 라인 위험 이라고 함
* 크게 바보가 되는 상황은 3가지로 분류 됨

<br></br>

### 1. 데이터 위험
* 데이터 의존성 문제 때문에 발생함(모든 명령어를 한번에 해결이 안됨)
* 한 명령어가 쓰고 있는 데이터를 다른 명령어가 해당 명령어의 데이터를 읽을려고 할 때 발생

**명령어 1**
```c
int a = 1;
int b = 2;
result1 = a + b;
```

**명령어 2**
```c
int c = 2
c+result1 = result2;
```
![alt text](<설명사진/읽기-쓰기 RAW 문제.png>)

<br></br>

### 2. 제어 위험
* `분기 명령어(if, goto)`로 인해 `프로그램 카운터(PC)`가 갑작스러운 변화에 의해 발생함
* `프로그램 실행(EX)`의 흐름이 바뀌어 프로그램 카운터 값이 갑자기 바뀌게 되면 미리 작업 중이던게 아무런 쓸모가 없어지게 됨

![alt text](<설명사진/제어 위험.png>)

<br></br>

### 3. 구조적 위험
* 서로 다른 명령어가 같은 자원에 접근을 시도했을 경우에 발생함

![alt text](<설명사진/구조적 위험.png>)

<br></br>
<br></br>

## 슈퍼 스칼라
![alt text](<설명사진/스크린샷 2025-03-28 오후 4.00.11.png>)

* 한번에 여러 개의 명령어를 동시에 실행하는 프로세서 설계 방식
* `단일 클럭 사이클(Clock Cycle)` 내에 두 개 이상의 명령어를 동시에 처리할 수 있는 아키텍처를 의미함
* 명령어를 병렬 방식으로 처리함 (한 클럭 내에서도 성능 Up)

<br></br>
<br></br>

## 파이프 라인 VS 슈퍼 스칼라

| 개념        | 특징                                          | 실행 방식                     |
|------------|----------------------------------------------|------------------------------|
| 파이프라인 | 여러 명령어가 겹쳐서 실행되지만, 한 사이클에 한 개의 명령어만 실행 | 각 사이클에 한 개의 명령어 실행 |
| 슈퍼스칼라  | 여러 명령어를 병렬로 실행하여 성능 향상               | 각 사이클에 여러 개의 명령어 실행 가능 |
