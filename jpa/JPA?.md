# JPA 
![alt text](<설명사진/[JPA intro] - JPA.png>)
* 자바 객체를 `관계형 데이터베이스(RDB)`에 `매핑(Mapping)`하기 위한 **자바 ORM 표준 인터페이스**
    * **ORM(Object Relational Mapping):** 객체와 RDB를 매핑 
* 자바 생태계의 ORM 기술의 표본

<br></br>

## JPA의 구조
![alt text](<설명사진/[JPA intro] - JPA 구현체들.png>)
* JPA는 <U>Java ORM을 위한 표준 명세</U>임
* JPA를 사용하기 위해선 JPA를 구현한 ORM 프레임워크를 선택해야함 
* `Hibernate`, `EclipseLink`, `DataNucleus` 등은 JPA를 구현한 `구현체(구현 라이브러리)`임
* 때문에 애플리케이션은 JPA를 통해 구현체에 종속되지 않고 ORM 기능을 사용할 수 있음


<br></br>

## JPA를 사용하는 이유
1. **높은 생산성**
    * SQL 쿼리를 직접 작성하지 않아도, 자바 객체를 저장하듯이 `EntityManager.persist()` 같은 메서드로 DB 작업이 가능함
    * 반복적인 CRUD 작업의 코드가 줄어들고, 비즈니스 로직에 집중할 수 있음
    * `객체 설계 → DB 설계`로 흐름이 바뀌면서, 도메인 중심의 개발이 가능해짐

2. **유지 보수의 편리성 증가**
    * SQL이 코드 여기저기에 퍼져 있는 전통 방식과 달리, JPA는 도메인 중심 코드로 유지보수가 쉬움
    * 필드명을 바꿔도 `해당 객체(Entity)`의 변경만으로 반영이 가능하므로 리팩토링이 수월함
    * 개발자의 실수로 SQL 문법 오류나 컬럼명 오류 가능성이 줄어듦 (컴파일 시점에서 오류 감지)

3. **패러다임의 불일치 해결**
    * 객체지향 언어와 관계형 데이터베이스는 근본적으로 데이터 처리 방식이 다름
        * **EX** 객체는 참조를 갖지만, RDB는 외래 키로 관계를 표현
    * JPA는 이런 차이를 중간에서 매끄럽게 매핑해줌
    * 객체 지향적인 사고와 모델링 그대로 DB에 대해서 작업할 수 있음

4. **성능**
    * 애플리케이션과 데이터 베이스 사이에서 다양한 최적화 기회를 제공
        * `1차 캐시`, `지연 로딩(Lazy Loading)`, `변경 감지(Dirty Checking)`, `쿼리 최적화 기능` 등...
        * `배치 처리`, `페이징`, `쓰기 지연(Write-behind)` 전략 등 다양한 성능 관련 기능 제공
    * SQL이 필요한 시점에만 실행되며, 필요한 데이터만 불러올 수 있음

5. **데이터 접근 추상화와 벤더 독립성**
![alt text](<설명사진/[JPA intro] - 벤더 독립성 .png>)
    * 특정 DBMS에 종속적인 SQL을 줄이고, JPA 인터페이스를 통해 DB 벤더 교체가 쉬움
    * SQL Dialect를 통해 DBMS별 SQL 차이를 자동으로 처리