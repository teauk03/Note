# TCP (Transmission Control Protocol)
* 데이터를 안전하게, 순서대로, 완전하게 전달하기 위해 만들어진 전송 계층의 프로토콜
* 전송 계층에서 포트 기반 통신과 데이터 흐름 관리를 담당하여 수행함

<br></br>

## 1. TCP의 특징
### 1.1. 연결 지향형 
* TCP는 데이터를 전송하기 전에 `3-way handshake` 라는 괴정을 통해 연결을 세팅함
* 연결이 끝나면 `4-way handshake` 라는 과정을 통해 연결을 종료함

### 1.2. 데이터의 순서를 보장함
* 전송한 데이터의 순서와 동일하게 데이터의 도착 순서를 정렬해줌

### 1.3. 데이터 손실을 복구함
* 데이터를 보내던 중에 패킷이 손실되면, 자동 재전송을 통해 복구함 

### 1.4. 흐름 제어
* 수신자의 버퍼가 가득 차지 않도록 윈도의 크기를 조절함

### 1.5. 혼잡 제어
* 네트워크의 상태를 보고 전송 속도를 동적으로 조절함

<br></br> 

## 2. TCP의 세그먼트 구조 
![alt text](<../설명사진/[전송 계층] TCP 세그먼트 헤더 구조.png>)
* `세그먼트(Segment)`는 전송 계층에서 데이터를 송수신할 때 사용하는 데이터 단위를 말함
* 상위 계층(애플리케이션 계층)에서 받은 데이터를 일정 크기로 나누어서 세그먼트라는 단위로 만들어서 전송
    * `MSS:` TCP로 전송할 수 있는 페이로드 max size


### 2.1. 송수신지 포트 
* 송신지 or 수신지 애플리케이션을 식별하는 포트가 명시됨

### 2.2. 순서 번호
![alt text](<../설명사진/[전송 계층] TCP 세그먼트 헤더 구조.png>)
* `순서 번호`가 명시되는 필드
    * **순서 번호:** 세그먼트의 올바른 순서를 보장하기 위해 <U>세그먼트 바이트 첫 부분에 부여되는 번호</U>
    * 초기 순서 번호 + 송신한 byte의 수
* **TCP의 신뢰성을 보장하기 위해 사용됨**

### 2.3. 확인 응답 번호
![alt text](<../설명사진/[전송계층] TCP 확인 응답 번호.png>)
* 송신한 쪽의 호스트가 보낸 세그먼트에 대한 응답
* 수신이 성공하기를 기대하는 순서 번호가 명시되는 필드
* **TCP의 신뢰성을 보장하기 위해 사용됨**

### 2.4. 제어 비트 
* 플래그 비트라고도 부르며, 현재 세그먼트에 대한 부가 정보를 나타냄
* 기본적으로 8bit로 구성됨
* 각 자리의 비트에는 각각 다른 의미를 가지는 TCP 동작에 대한 의미를 가짐
    * `CWR`: 혼잡 제어를 위해 송신 측 호스트가 윈도우 크기를 줄였음을 알림
    * `ECE`: 네트워크 혼잡이 감지 되었음을 알림
    * `URG`: 간급 데이터가 포함되었음을 표시 
    * **`ACK`**: <U>이전에 받은 데이터에 대한 확인 응답임을 표시</U>
    * `PSH`: 데이터를 즉사 상위 계층(애플리케이션 계층)으로 전달하라는 의미
    * `RST`: 연결을 즉시 재설정 하는 의미
    * **`SYN`**: <U>연결 설정을 위한 동기화 요청 (3-way handshake 시작)</U>
    * **`FIN`**:<U>연결을 정상적으로 종료하겠다는 의미</U>

### 2.5. 윈도우
* `수신 윈도우`의 크기가 명시됨
    * **수신 윈도우:** 헌 본애 수신하고자 하는 데이터의 양

<br></br> 

## 3. TCP 연결 수립과 종료 
![alt text](<../설명사진/[전송계층] TCP 통신 단계.png>)


### 3.1. 연결 수립 (3-way handshake)
![alt text](<../설명사진/[전송 계층] 3way handshake 과정.png>)
* TCP의 연결 수립은 `3-way handshake` 라는 과정을 통해 이루어짐
* **3-way handshake:** 이름과 같이 3개의 단계로 이루어진 연결 수립 과정을 의미함
* 처음 연결을 시작하는 호스트의 연결 수립 과정을 `액티브 오픈`이라고 함
* 연결 요청을 받고 요청 결과에 따라 연결을 수립하는 과정을 `패시브 오픈`이라고 함

<br></br>

### 3.2. 연결 종료 (4-way handshake)
![alt text](<../설명사진/[전송계층] 연결 해제 과정.png>)
* 데이터 송수신이 끝난 후 TCP 연결은 4-way handshake를 통해 종료됨
* 해당 과정은 송수신 호스트가 각자 한번 씩 FIN과 ACK을 주고 받으며 이루어짐
    1.	**호스트1 → 호스트2:**  FIN (연결 종료 요청)
	2.	**호스트2 → 호스트1:**  ACK (요청 확인)
	3.	**호스트2 → 호스트1:**(상대방도 종료 요청)
	4.	**호스트1 → 호스트2:** ACK (확인)
* 먼저 연결을 종료하려는 호스트에 의해 수행되는 과정을 `액티브 클로즈` 라고 함
* 연결 종료를 받아드리는 호스트에 의해 수행되는 과정을 `패시브 클로즈` 라고 함


<br></br>

## 4. TCP의 연결 상태
* TCP에선 신뢰할 수 있는 통신을 위해 `다양한 연결 상태`를 가지고 있음
    * **상태(state):** 현재 어떤 통산 과정에 있는지를 나타내는 정보
* 위와 같은 이유로 상태를 유지하고 활용한다는 점에서 `TCP는 stateful 프로토콜`이라고도 함 

| **상태 분류**         | **상태 이름**      | **설명**                                                   |
| ----------------- | -------------- | -------------------------------------------------------- |
| 🔴 연결이 수립되지 않은 상태 | `CLOSED`       | 연결이 **완전히 끊긴 기본 상태**. 연결을 시작하지 않았거나, 종료가 완료된 상태.         |
|                   | `LISTEN`       | `서버가 연결 요청(SYN)`을 기다리는 상태. (`listen()` 호출 이후)      |
| 🟡 연결 수립 중인 상태    | `SYN_SENT`     | 클라이언트가 SYN을 전송하고 **ACK 응답을 기다리는 상태**.                    |
|                   | `SYN_RECEIVED` | 서버가 SYN을 받고 **SYN+ACK를 응답한 상태**. 클라이언트의 최종 ACK를 기다림.     |
| 🟢 연결 수립 완료       | `ESTABLISHED`  | **연결이 성공적으로 성립**되어 **데이터 송수신이 가능한 상태**.                  |
| 🔵 연결 종료 중인 상태    | `FIN_WAIT_1`   | `연결 종료(FIN)`를 먼저 요청한 측이 상대의 ACK를 기다리는 상태.          |
|                   | `FIN_WAIT_2`   | 상대방이 ACK를 보내면, **이제 상대의 FIN을 기다리는 상태**.                  |
|                   | `CLOSING`      | 양쪽이 동시에 FIN을 보냈을 때, **양쪽 모두 ACK를 기다리는 중간 상태**. 드물게 발생.   |
|                   | `TIME_WAIT`    | FIN-ACK 절차 후, **지연된 패킷 처리나 재전송을 방지하기 위해 일정 시간 기다리는 상태**. |
|                   | `CLOSE_WAIT`   | 상대방이 FIN을 먼저 보냈을 때, **내가 ACK는 했지만 아직 FIN은 안 보낸 상태**.     |
|                   | `LAST_ACK`     | 내가 FIN까지 보낸 뒤, **상대의 마지막 ACK를 기다리는 상태**.                 |

<br></br>

