# HTTP
* **H**yper**T**ext **T**ransfer **P**rotocol 의 약자로 허아퍼 텍스트를 주고 받기 위한 표준 통신 프로토콜
    * **Hypertext:**  한 문서(HTML)에서 다른 문서로 `비선형적(Non-linear)`으로 이동할 수 있는 텍스트 
* 단순히 데이터를 표현하는 것이 아니라, 랑크로 연결된 문서들을 서버와 클라이언트 사이에서 주고받기 위한 규칙

<br></br>

## 1. HTTP의 특징

### 1.1. 요청-응답 기반
![alt text](<../설명사진/[응용 계층]  HTTP - 요청과 응답.png>)
* 클라이언트 - 서버 모델에서 동작하는 요청 - 응답 구조를 따름
* 클라이언트가 서버에 요청을 보내면 서버는 그 요청을 처리하고 적절한 응답을 반환

<br></br>


### 1.2. 미디어 독립적
![햗ㅇ](<../설명사진/[응용 계층] HTTP 미디어 독랍적 성향.png>)
* 데이터의 형식에 구애받지 않고 어떤 종류(타입)의 데이터든 전송할 수 있음
    * HTTP에서 주고 받는 자원의 종류를 `미디어 타입 (media type)`이라고 함
    * 이 미디어 타입은 `/`를 기준으로 하는 `타입/서브타입 형식`으로 구성됨

| 타입 (`type`)      | 설명                      | 주요 서브타입  | 서브타입 설명                                  |
|-------------------|---------------------------|----------------------------|------------------------------------------------|
| `text`            | 텍스트 형식의 데이터       | `plain`                    | 일반 텍스트 (ex. `.txt`)                        |
|                   |                           | `html`                     | HTML 문서                                       |
|                   |                           | `css`                      | 스타일시트                                      |
|                   |                           | `csv`                      | 쉼표로 구분된 값                                |
|                   |                           | `javascript`               | 자바스크립트 코드                               |
| `image`           | 이미지 데이터             | `png`                      | 무손실 압축 이미지                              |
|                   |                           | `jpeg`                     | 손실 압축 이미지                                |
|                   |                           | `gif`                      | 움직이는 이미지                                 |
|                   |                           | `svg+xml`                  | 벡터 기반의 이미지                              |
| `video`           | 동영상 데이터             | `mp4`                      | 표준 동영상 포맷                                |
|                   |                           | `webm`                     | 웹 최적화 동영상                                |
|                   |                           | `mpeg`                     | MPEG 포맷 비디오                                |
| `audio`           | 오디오 데이터             | `mpeg`                     | MP3 등                                          |
|                   |                           | `ogg`                      | 오픈 포맷 오디오                                |
|                   |                           | `wav`                      | 무압축 오디오                                   |
| `application`     | 응용 프로그램 데이터       | `json`                     | JSON 포맷 데이터                                |
|                   |                           | `xml`                      | XML 포맷 데이터                                 |
|                   |                           | `pdf`                      | PDF 문서                                        |
|                   |                           | `zip`                      | 압축 파일                                       |
|                   |                           | `octet-stream`             | 바이너리 파일 (다운로드용)                      |
| `multipart`       | 다양한 데이터 묶음         | `form-data`                | 폼 전송 (파일 포함)                             |
|                   |                           | `mixed`                    | 다양한 타입의 데이터 혼합                       |
|                   |                           | `alternative`              | 동일 콘텐츠의 다양한 표현 (ex. HTML + Text 메일) |

<br></br>

### 1.3. 비상태성 (Stateless)
* 클라이언트의 각 요청마다 상태를 유지하지 않음 (Stateless)
* 서버는 이전 요청에 대한 정보를 저장하지 않고, <U>새로운 요청마다 독립적으로 처리 됨</U>

<br></br>

### 1.4. 지속 연결 (Persistent Connection)
* HTTP(ver 1.1)부터 기본적으로 하나의 TCP 연결로 여러개의 요청과 응답을 처리할 수 있음 
    * 이 연결 방식을 `keep-Alive` 연결이라고 함
* 매 요청마다 TCP 연결을 만들 필요가 없어서 효율적인 성능이 가능


<br></br>


## 2. HTTP 메시지 구조
* HTTP 메시지의 구조는 크게 `요청(Request)`와 `응답(Response)` 형태로 나뉘어짐
    * **요청:** 시작라인 = 요청 라인
    * **응답:** 시작라인 = 상태 라인
* 아래는 요청과 응답 두 형태의 공통적인 구조
```shell
[시작라인(Start Line)] - 요청 또는 응답의 목적을 설명하는 첫 줄
[해더 (Header)] - 청/응답에 대한 부가 정보를 담은 (K-V) 쌍


[본문(Body)] - 실제 데이터 
```

<br></br>
 
### 2.1. 요청 메세지 (HTTP Request)
```shell
요청 라인 = [메서드 + 요청 대상 + HTTP버전]
```
1. **메서드 (method)**
    * 클라이언트가 서버의 자원에 대해 수행할 작업의 종류를 나타냄
2. **요청 대상 (request-target)**
    * HTTP 요청을 보낼 서버의 자원
    * 주로 URL이 경로가 명시됨 
3. **HTTP 버전**
    * HTTP의 버전이 표기
    * HTTP/version


 <br></br>
 
### 2.2. 응답 메세지 (HTTP Response)
```shell
상태 라인 = [HTTP버전 + 상태 코드 + 이유 구문]
```
1. **HTTP 버전**
    * HTTP의 버전이 표기
    * HTTP/version
2. **상태 코드(status code)**
    * 요청에 대한 결과를 나타내는 3자리의 정수
3. **이유 구문**
    * 상태 코드에 대한 문자열 형태의 설명

<br></br>

## 3. HTTP 메서드 
* 클라이언트가 서버에게 수행하길 원하는 동작을 명시하는 명령어
* 각 메서드는 의미와 사용 목적이 각각 다름

| HTTP 메서드    | 설명                                   | 필요한 헤더                                                                      |
| ----------- | ------------------------------------ | --------------------------------------------------------------------------- |
| **GET**     | 리소스를 조회 (서버의 상태나 데이터를 가져옴)           | `Accept`, `Authorization`, `Cookie`, `If-None-Match`, `If-Modified-Since`   |
| **HEAD**    | GET과 같지만 응답 본문 없이 헤더만 받음 (상태 확인용)    | `Accept`, `Authorization`, `Cookie`                                         |
| **POST**    | 리소스를 생성하거나, 서버에 데이터를 제출              | `Content-Type`, `Authorization`, `Accept`, `Content-Length`, `Cookie`       |
| **PUT**     | 전체 리소스를 대체하여 업데이트                    | `Content-Type`, `Authorization`, `Content-Length`, `If-Match`               |
| **PATCH**   | 리소스의 일부만 업데이트                        | `Content-Type`, `Authorization`, `Content-Length`, `If-Match`               |
| **DELETE**  | 리소스를 삭제                              | `Authorization`, `If-Match`, `Cookie`                                       |
| **CONNECT** | 프록시를 통해 서버와 터널 연결 (HTTPS 등)          | `Host`, `Proxy-Authorization`                                               |
| **OPTIONS** | 서버가 지원하는 메서드 확인 (CORS 사전 요청 시 주로 사용) | `Access-Control-Request-Method`, `Access-Control-Request-Headers`, `Origin` |
| **TRACE**   | 요청 루프백 (서버가 받은 요청을 그대로 반환) - 디버깅용    | 거의 없음 (기본 헤더만 사용)                                                           |


<br></br>

## 4. HTTP 싱태 코드 
* 서버가 클라이언트의 응답대해 어떻게 처리 했는지 알려주는 3자리의 숫자로 알려주는 응답 코드 
* 첫 번쨰 자릿구에 따라 처리의 범주에 의미가 달라짐

| 범위  | 의미                          | 설명                                         |
|--------|-------------------------------|----------------------------------------------|
| 1xx   | 정보(Informational)           | 요청을 받았으며, 처리 중에 있음을 나타냄     |
| 2xx   | 성공(Success)                 | 요청이 정상적으로 처리되었음                 |
| 3xx   | 리다이렉션(Redirection)       | 추가 조치가 필요함 (다른 URL로 이동 등)      |
| 4xx   | 클라이언트 오류(Client Error) | 요청에 잘못이 있음                           |
| 5xx   | 서버 오류(Server Error)       | 서버에서 요청을 처리하는 데 실패             |

<br></br>

### 4.1. 200번대
* 클라이언트의 요청이 성공했음을 의미

| 상태 코드 | 이유 구문         | 설명                                                                 |
|------------|------------------|----------------------------------------------------------------------|
| 200        | OK               | 요청이 성공적으로 처리되었고, 응답 본문에 결과가 포함됨               |
| 201        | Created          | 요청이 성공적으로 처리되었으며, <U>새로운 리소스가 생성되었음</U>           |
| 202        | Accepted         | 요청이 접수되었지만, 처리가 완료되지 않았음 (비동기 처리에 주로 사용) |
| 204        | No Content       | 요청이 성공적으로 처리되었지만, 응답 본문이 없음                     |
<br></br>

### 4.2. 300번대
* `리다이렉션(Redirection)`에 관련된 상태 코드
    * **리다이렉션(Redirection):** 요청을 완수하기 위해 추가적인 조치가 필요한 상태
* 리다렉션은 크게 `영구적인 리다이렉션`과 `일시적인 리다이렉션`이 있음

<br></br>

#### 4.2.1. 영구적인 리다이렉션
![alt text](<../설명사진/[응용 계층] HTTP 상태코드 - 301번 영구적 리다이렉션.png>)
* 해당 리소스의 위치가 영원히 바뀌었음을 브라우저나 클라이언트에게 알리는 것
* 기존의 URL에 요청 메세지를 날리면 새로운 URL로 리다이렉션됨
* 캐싱도 되고, 검색엔진도 새 위치로 인식됨

| 상태코드    | 이름                 | 설명                 | 메서드 유지 여부             | 클라이언트 동작           | 사용 이유                      |
| ------- | ------------------ | ------------------ | --------------------- | ------------------ | -------------------------- |
| **301** | Moved Permanently  | 리소스가 **영구적으로 이동됨** | ❌  | 새 주소로 이동 후 **캐시**함 | 도메인 변경, HTTP → HTTPS 강제 이동 |
| **308** | Permanent Redirect | 리소스가 **영구적으로 이동됨** | ✅             | 요청 방식 그대로 새 주소로 전송 | POST/PUT 같은 메서드도 유지하며 이동 시 |


<br></br>

#### 4.2.2. 일시적인 리다이렉션
![alt text](<../설명사진/[응용 계층] HTTP 상태코드 - 303번 일시적 리다이렉션에 대한 설명 사진 추가.png>)
* 리소스의 위치가 잠시 바뀐 것이며, 다음 요청은 원래 주소로 요청하라는 의미
* 어떤 URL에 일시적인 리다이렉트와 관련 상태코드를 받았으면 요청을 보낸 URL의 정보를 기억해야함 
* 캐싱하지 않고, 요청한 주소는 유지

| 상태코드    | 이름                              | 설명                    | 메서드 유지 여부                | 클라이언트 동작                 | 사용 이유                                |
| ------- | ------------------------------- | --------------------- | ------------------------ | ------------------------ | ------------------------------------ |
| **302** | Found *(기존: Moved Temporarily)* | 리소스가 **임시적으로 이동됨**    | ❌  | 다음 요청도 **원래 주소로** 해야 함   | 임시 점검, 임시적인 리소스 위치 변경                |
| **303** | See Other                       | 다른 URL로 **GET 요청** 유도 | ✅ (항상 GET으로 전환)          | POST 후 결과를 GET으로 요청하게 유도 | POST → 결과 페이지 이동 시 (ex: 결제 후 완료 페이지) |
| **307** | Temporary Redirect              | 리소스가 **임시적으로 이동됨**    | ✅ (메서드 유지)               | 요청 메서드 그대로 **다시 전송**     | REST API 요청 중 임시 변경 상황에서 사용          |


<br></br>

### 4.3. 400번대
![alt text](<../설명사진/[응용 게층] 4xx error intro.png>)
* <U>클라이언트에 의한 에러</U>가 있음을 알려주는 상태 코드
* 서버가 처리할 수 없는 요청, 존재하지 않는 자원 요청 등 **클라이언트가 서버에 맞지 않는 요청을 보낼 때** 발생


| 상태 코드 | 이유 구문  | 설명                                                                          |
| ----- | ---------------------- | --------------------------------------------------------------------------- |
| `400` | **Bad Request**        | 요청이 문법적으로 잘못되었거나 서버가 이해할 수 없는 요청일 때 발생         |
| `401` | **Unauthorized**       | 인증이 필요한데 인증 정보가 없거나 잘못됨. (로그인 안 하고 접근할 때)                                |
| `403` | **Forbidden**          | 서버가 요청을 이해했지만, 권한이 없어서 거부함. (관리자 전용 페이지에 일반 유저가 접근 시)                    |
| `404` | **Not Found**          | 요청한 리소스를 찾을 수 없음. (존재하지 않는 URL 접근)                                       |
| `405` | **Method Not Allowed** | 요청한 리소스는 존재하지만, 허용되지 않은 HTTP 메서드를 사용했을 때 발생. (GET만 가능한 URL에 POST 요청한 경우) |

#### 4.3.1. 401 (Unauthorized)
![alt text](<../설명사진/[응용 게층] HTTP 상태코드 - 401 (Unauthorized .png>)
* 클라이언트가 인증이 필요한 리소스에 접근했지만, <U>인증 자격이 없거나 인증에 실패</U>했음을 의미 
* `WWW-Authenticate 헤더`로 인증 방식을 제시하는 메세지

#### 4.3.2. 403 (Forbidden)
![alt text](<../설명사진/[응용 게층] HTTP 상태코드 - 403 (Forbidden) .png>)
* 클라이언트가 요청한 리소스에 대해 접근 권한이 없기 때문에 서버가 요청을 거부한 상태를 의미
* `WWW-Authenticate 헤더`로 인증 방식을 제시하지 않음 (이미 인증이 완료된 상태의 에러이기 때문)

#### 4.3.3. 404 (Not Found)
![alt text](<../설명사진/[응용 게층] HTTP 상태코드 - 404 (Not Found).png>)
* 클라이언트가 접근하고자 하는 자원이 존재하지 않음을 의미


#### 4.3.4. 405 
![alt text](<../설명사진/[응용 게층] HTTP 상태코드 - 405 (Method Not Allowed).png>)
* 클라이언트가 접근한 자원은 존재하지만, <U>서버가 해당 HTTP 메서드를 지원하지 않음</U>을 알림
* 요청의 `행동 방식(method)` 자체가 서버에 정의되어 있지 않거나 허용되지 않은 경우


<br></br>

### 4.4. 500번대
* 서버가 클라이언트의 요청을 처리를 실패함을 알리는 상태코드
* 간략히 서버 에러 

| 상태 코드   | 이유 구문                   | 설명                                                      | 발생 이유                                                             |
| ------- | ----------------------- | ------------------------------------------------------- | --------------------------------------------------------------------- |
| **500** | `Internal Server Error` | 서버 내부에서 처리 중 **예기치 않은 오류** 발생. 정확한 원인을 서버가 명확히 전달하지 못함. | - 코드에 예외(Exception) 발생<br>- DB 연결 실패<br>- 의존성 모듈 오류<br>- Null 값 처리 안됨 |
| **501** | `Not Implemented`       | 클라이언트의 요청 메서드/기능을 **서버가 지원하지 않음**.                      | - 서버가 `PATCH`, `PUT` 등 일부 HTTP 메서드를 구현하지 않음<br>- 새 기능 구현이 아직 안 됨      |
| **502** | `Bad Gateway`           | 프록시/게이트웨이 서버가 **하위 서버로부터 올바른 응답을 받지 못함**.               | - Nginx나 로드밸런서가 백엔드와 통신 실패<br>- 하위 서버 다운<br>- 잘못된 포맷의 응답 수신           |
| **503** | `Service Unavailable`   | 서버가 **일시적으로 요청을 처리할 수 없음**. 유지보수나 과부하 등의 이유.            | - 트래픽 과다<br>- 서버 유지보수 중<br>- 서버 리소스 부족 (메모리/CPU 폭주)                   |
| **504** | `Gateway Timeout`       | 프록시/게이트웨이 서버가 **지정된 시간 내 하위 서버의 응답을 받지 못함**.            | - 백엔드 서버 지연<br>- DB 쿼리 타임아웃<br>- 하위 서버 무한 루프 등                        |
