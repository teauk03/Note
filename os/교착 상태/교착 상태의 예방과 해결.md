# 1. 교척 상태의 예방 (prevention)
* <U>교착 상태의 발생 조건들 중에 하나를 제거해서 교착이 이론적으로 불가능하게 만드는 방법</U>

| 방법            | 제거 조건     | 설명                                        |
| ------------- | --------- | ----------------------------------------- |
| **자원 공유 허용**  | 상호배제 제거   | 자원을 동시에 사용 가능하게 설계       |
| **점유와 대기 금지** | 점유와 대기 제거 | 프로세스가 필요한 자원을 한 번에 모두 요청 |
| **선점 허용**     | 비선점 제거    | 자원이 점유 중이라면 강제로 회수하여 다른 프로세스에 할당          |
| **순환 대기 방지**  | 순환대기 제거   | 자원에 고유 번호를 매겨, 항상 번호가 증가하는 방향으로만 요청       |

* 이론적으로 아주 아름다운 방법이지만 현실의 자원 낭비가 매우 낭비되어지며 비용과 유지보수가 힘들어짐
* 위의 이유로 예방 방법은 선호되지 않음


<br></br>

# 2. 교착 상태 회피 (avoidance)
* 교착 상태가 발생하지 않을 정도로 <U>조금 씩 자원을 할당하여 안전한 상태만 허용하는 방법</U>
* 교착 상태가 발생하기 전에 시스템에서 교착 상태가 발생할 수 있다고 판단해서 자원 할당을 조정함
    * 여기에서 시스템은 현재 프로세스의 최대 자원 요구량을 알고 있음
    * 자원을 조금씩 할당하면서 항상 안전한 상태인지 검사
    * 만약 어떤 요청을 받아드렸을 때 안전상태가 유지되지 않으면 할당을 거절

## 2.1. 안전 상태와 불안정 상태
* **안전 상태 (Safe State):** 프로세스가 정상적으로 자원을 할당 받고 종료할 수 있는 상태
* **불안전한 상태 (Unsafe State):** 프로세스가 교착 상태가 밯생할 수 있는 위험이 존재하는 상태


## 2.2. 안전 순서열
* 시스템 교착 상태 없이 프로세스에 안전하게 자원을 할당할 수 있게 하는 순서
* 위의 안전 상태와 불안정한 상태는 이 안전 순서열을 보고 프로세스가 안전한 상태인지 불안정한 상태인지 알 수 있음
    * **안전한 경우**
    ![alt text](<../설명사진/[OS] 안전 순서열 - safe state.png>)
    * **불안전한 경우**
    ![alt text](<../설명사진/[OS] 안전 순서열 - unsafe state.png>)

<br></br>

# 3. 교착 상태 검출 후 회복
* 교착 상태를 사전에 예방하는 것이 아니라, 교착 상태가 발생한 후 조치를 뜻함
    * 이 과정은 OS가 주기적으로 자원 그래프라는 것을 분석해서 교착을 찾고 회복 과정을 거침


## 3.1. 자원 선점을 통한 회복
* 교착 상태가 해결될 때 까지 한 프로세스에 자원을 몰아서 회복하는 방식을 사용
    * 교착 상태가 벌어진 상황 
    ![alt text](<../설명사진/[OS] 자원 선점을 통한 회복 (1).png>)
    * 하나의 프로세스에 자원을 몰아서 준 상황
    ![alt text](<../설명사진/[OS] 자원 선점을 통한 회복 (2).png>)
* 이렇게 자원을 선점하여 회복하는 경우 몇가지의 문제가 발생하게 됨
    1. 작업 중인 프로세스가 자원이 선점된 프로세스의 영향 때문에 작업이 강제 롤백이 될 수 있음
    2. 같은 프로세스가 계속 자원을 빼앗아가는 기아 문제가 발생할 수 있음
    3. 롤백 시에 롤백의 기준이 필요함

## 3.2. 강제 종료를 통한 회복
![alt text](<../설명사진/[OS] 강제 종료를 통한 회복.png>)
* 가장 단순하고 강력한 방법으로 교착 상태인 프로세스를 강제로 종료하여 자원을 회수하는 방법을 사용
* 다시 자원을 빼앗아버리고 다른 프로세스에 재할당함

<br></br>

# 4. 번외 **(타조 알고리즘 사용)** 
* 교착 상태가 일어나도 아무런 문제가 없는 것처럼 대처하게 함 (무시)