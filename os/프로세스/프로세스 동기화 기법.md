# 뮤텍스 락 (Mutex Rock)

* 상호 배제(mutual exclusion)의 약자
* 여러 프로세스나 스레드가 동시에 공유 자원에 접근하려고 할 때, 한 번에 하나만 들어올 수 있도록 제한(Lock)하는 기법
* 한 번의 하나의 임계구역에 진입하게 해서, 임계구역에 동시에 접근하는 상황을 예방함
* `잠금(Lock)`과 `잠금 해제(Unlock)`으로 이루어진 메커니즘을 사용

![alt text](<../설명사진/[OS] 프로세스 동기화 기법 - 뮤텍스락 (1).png>)
![alt text](<../설명사진/[OS] 프로세스 동기화 기법 - 뮤텍스락 (시퀀스).png>)
```python
import threading
import time

lock = threading.Lock()

def process(name, work_time):
    print(f"{name}: acquire() 호출")
    lock.acquire()
    print(f"{name}: lock = true -> 임계 구역 진입")
    
    # 임계 구역 자원 사용 중
    time.sleep(work_time)
    
    print(f"{name}: release() 호출 -> lock = false (임계 구역 해제)")
    lock.release()

# 프로세스(스레드) 생성
p1 = threading.Thread(target=process, args=("Process 1", 2))
p2 = threading.Thread(target=process, args=("Process 2", 2))
p3 = threading.Thread(target=process, args=("Process 3", 2))
p4 = threading.Thread(target=process, args=("Process 4", 2))

# 실행 (동시에 시작)
p1.start()
p2.start()
p3.start()
p4.start()

# 모든 스레드 종료 대기
p1.join()
p2.join()
p3.join()
p4.join()
```

<br></br>

# 세마포어(Semaphore)
* 카운트 값을 가진 정수형 변수인 세마포(Semaphore)를 두 가지 기본 연산(P: 카운트 1감소, V: 카운트 1증가)만 수행할 수 있는 atomic함수로 제어하는 기법
    * 여러 프로세스나 스레드가 <U>공유 자원에 접근하는 것을 제어</U>하기 위해 사용되는 **동기화 도구**
    * 카운트 값을 가졌으며,원자적으로 조작되는 정수형 변수임
    * 기본적으로 `상호배제 알고리즘`을 사용함 (Mutex)

## 세마포어의 구성 요소
* **S(전역 변수) :** 임계 구역애 진입할 수 있는 프로새스의 갯수를 표현
* **wait() :** 임계 구역에 대기해야할지 진입해야할지 처리하는 함수
* **Signal() :** 임계 구역에서 대기하고 있는 프로세스의 진입 허가의 신호를 주는 함수

![alt text](<../설명사진/[OS] 프로세스 동기화 기법 - 세마포어 (동작 그림).png>)

```java
import java.util.LinkedList;
import java.util.Queue;

// 세마포어
class Semaphore {
    private int value; //세마포어 값. (사용 가능한 자원 갯수)
    private Queue<Process> blockedQueue = new LinkedList<>(); // 대기 중인 프로세스들을 저장하는 큐

    // 초기 세마포어 값 설정
    public Semaphore(int value) {
        this.value = value;
    }

    // Wait() 함수 — 프로세스가 자원을 요청할 때 호출
    public synchronized void waitSem(Process p) {
        System.out.println(p.name + " -> Wait() 호출");

        // 자원이 남아있으면 자원을 차지하고 임계구역에 진입
        if (value > 0) {
            value--; // 자원 하나 차지
            p.state = "Running";
            System.out.println("✅ 자원 사용 가능 -> " + p.name + " 임계구역 진입 (S = " + value + ")");
        } 
        // 자원이 없다면 Blocked Queue로 이동
        else {
            p.state = "Blocked";
            blockedQueue.add(p); // 큐에 넣고 대기
            System.out.println("⚠️ 자원 없음 -> " + p.name + " Blocked Queue로 이동");
        }
    }

    // Signal() 함수 — 프로세스의 자원 사용 후 반환
    public synchronized void signal() {
        value++; // 자원 하나 반환
        System.out.println("자원 반납 완료 (S = " + value + ")");

        // 만약 대기 중인 프로세스가 있다면, 하나를 깨워서 Ready 상태로 전환
        if (!blockedQueue.isEmpty()) {
            Process p = blockedQueue.poll(); // 맨 앞의 프로세스 꺼냄
            p.state = "Ready";
            System.out.println("🔔 " + p.name + " -> Ready Queue로 이동 (자원 사용 가능)");

            // 자원을 점유
            value--; // 자원 다시 점유
            p.state = "Running";
            System.out.println("➡️ " + p.name + " -> Running (S = " + value + ")");
        }
    }
}

// 프로세스
class Process {
    String name;   // 프로세스 이름
    String state;  // 프로세스 상태

    public Process(String name) {
        this.name = name;
        this.state = "New";
    }
}

// 시뮬레이션
public class SemaphoreDemo {
    public static void main(String[] args) {
        // 세마포어 초기값 2 
        Semaphore sem = new Semaphore(2);

        // 프로세스 3개 생성
        Process p1 = new Process("Process 1");
        Process p2 = new Process("Process 2");
        Process p3 = new Process("Process 3");

        // -----------------------------
        // [1단계] Process 1, 2가 자원 사용
        // -----------------------------
        sem.waitSem(p1);
        sem.waitSem(p2);

        // -----------------------------
        // [2단계] Process 3은 자원이 없어 Blocked Queue로 이동
        // -----------------------------
        sem.waitSem(p3);

        // -----------------------------
        // [3단계] Process 1이 작업 완료 -> 자원 반환(Signal)
        // -----------------------------
        System.out.println("\n--- Process 1 작업 완료 후 Signal() 호출 ---");
        sem.signal();

        // -----------------------------
        // [4단계] Process 2도 작업 완료 -> 자원 반환
        // -----------------------------
        System.out.println("\n--- Process 2 작업 완료 후 Signal() 호출 ---");
        sem.signal();
    }
}

```

```shell
Process 1 -> Wait() 호출
✅ 자원 사용 가능 -> Process 1 임계구역 진입 (S = 1)
Process 2 -> Wait() 호출
✅ 자원 사용 가능 -> Process 2 임계구역 진입 (S = 0)
Process 3 -> Wait() 호출
⚠️ 자원 없음 ->Process 3 Blocked Queue로 이동

--- Process 1 작업 완료 후 Signal() 호출 ---
자원 반납 완료 (S = 1)
🔔 Process 3 -> Ready Queue로 이동 (자원 사용 가능)
➡️ Process 3 -> Running (S = 0)

--- Process 2 작업 완료 후 Signal() 호출 ---
자원 반납 완료 (S = 1)
```

<br></br>


# 모니터 (Monitor)
* 세마포 기법에서 발생할 수 있는 문제를 보안한 기법으로 동기화를 위해 만들어진 상위 수준의 동기화 도구
* **데이터와 관련된 함수를 캡슐화** 하여 하나의 프로세스 당 하나의 코드를 실행하도록 설계 됨 (뮤텍스 + 조건 변수)

## 모니터의 필요성
* 시스템이 거대해지고, 그에 따라 복잡해질 수 록 세마포어나 뮤텍스를 직접 사용하게 되면 다음과 같은 문제가 발생할 수 있음
* 아래의 문제를 해결하기 위해 `모니터`라는 개념이 생겨남

1. 세마포어를 누락하는 경우 

![alt text](<../설명사진/[OS] 모니터가 필요한 이유 (1).png>)

2. wait() 함수와 signal 함수의 순서가 바뀜

![alt text](<../설명사진/[OS] 모니터가 필요한 이유 (2).png>)

3. wait() 함수와 signal 함수를 중복해서 사용함

![alt text](<../설명사진/[OS] 모니터가 필요한 이유 (3).png>)

## 모니터의 구성 요소
* 모니터는 `클래스/객체` 단위의 보호 구역
* 객체 내부의 메서드 중에서 하나의 스레드만 실행되게 설계 되어 있음

| 구성 요소                         | 설명                                           |
| ----------------------------- | -------------------------------------------- |
| **공유 데이터**       | 스레드들이 함께 사용하는 자원                             |
| **뮤텍스 락**         | 동시에 하나의 스레드만 접근하도록 보장                        |
| **조건 변수** | 특정 조건이 만족될 때까지 스레드가 기다리거나 깨움 (wait / notify) |


## 모니터의 동작 과정
![alt text](<../설명사진/[OS] 모니터의 동작 과정.png>)

| 단계 | 동작                               | 상태 변화                    |
| -- | -------------------------------- | ------------------------ |
| 1.  | 프로세스들이 임계 구역 진입 시도               | 상호배제 큐에서 대기            |
| 2.  | 한 프로세스가 임계 구역에 진입                | 공유 자원 접근                 |
| 3.  | 조건 불충족 시 `x.wait()` 호출           | 조건 변수 큐로 이동            |
| 4.  | 조건 충족 시 `x.signal()` 호출 | 조건 큐의 프로세스가 다시 준비 상태로 이동 |
| 5.  | 깨어난 프로세스가 임계 구역으로 돌아와 실행         | 공유 자원 접근 완료              |
